import {Clothes, ClothingPart, Clothing} from "./clothing";
import {Part} from "../parts/part";
import {Layer} from "../util/canvas";
import {
	drawPoints,
    extractPoint,
    splitCurve,
    clone,
	adjust,
	interpolateCurve,
	transformCurve,
	reflect,
	breakPoint,
} from "drawpoint/dist-esm";
import {adjustColor} from "../util/utility";
import {Pants,CoveredButtPart} from "./pants";
import {
	findBetween,
	getLimbPoints,
	getLimbPointsAbovePoint,
	getLacingPoints,
	polar2cartesian,
} from "../util/auxiliary";
import {calcBelt} from "./accessory";

export function calcSuperPantsTop(ex){
	let out;
	let hip;
	let thighOut;
		
	//TOP
	if(this.waistCoverage>0){ //ie includes the hip
		let temp = splitCurve((1-this.waistCoverage),ex.waist,ex.hip);	
		out = extractPoint(temp.left.p2);
		hip = temp.right.p2;
        thighOut = ex.thigh.out;
	}else{
		let temp = splitCurve(Math.abs(this.waistCoverage),ex.hip,ex.thigh.out);	
		out = extractPoint(temp.left.p2);
		//hip;
		thighOut = temp.right.p2;
	}
	
	const waistCurve = out.y - ex.hip.y;
	let top = {
		x: -0.2,  
		y: ex.pelvis.y + waistCurve * 1.2
	};

	out.cp1 = {
		x: out.x * 0.5 + top.x * 0.5,
		y: top.y
	};
	
	return {
		top,
		out, 
		hip,
		thighOut,
	}
}

export function calcSuperPants(ex){
	const max_skirt_width = 50;
	const {top,out,hip,thighOut} = calcSuperPantsTop.call(this,ex);
	
	let groin = adjust(ex.groin,-0.2,0);
	if(this.innerLoose<1){
		groin.cp1 = {
			x: groin.x * 0.5 + ex.thigh.top.x * 0.5,
			y: groin.y
		};
	}
		
	//OUTER:	
	let outerPoints = [];
			
	const addPointsStart = []; //ie should be hip included?
		addPointsStart[0] = out;
		addPointsStart[1] = (out.y>ex.hip.y) ? hip : void 0;
			
	const addPointsMid = []; //ie should be muscles included?
		if(typeof ex.quads !== "undefined"){
			addPointsMid[0] =  clone(ex.quads.top);
			addPointsMid[0].x =  ex.thigh.out.x;
			addPointsMid[1] = clone(ex.quads.out);
		}
				
	if(this.outerLoose>=1){ //SKIRT
		let totalLegLength = ex.hip.y-( (ex.hip.y-ex.ankle.out.y)*this.legCoverage );
		if (totalLegLength<ex.thigh.out.y){ //long skirt
			outerPoints = getLimbPoints(ex.hip,ex.ankle.out,this.legCoverage,...addPointsStart,thighOut);
			
			let index;
			if(this.bustle){
				index=outerPoints.length;
				outerPoints[index] = extractPoint(ex.thigh.out);
			}else{
				index=outerPoints.length-1;
				outerPoints[index] = clone(ex.thigh.out);
			}
					
			outerPoints[index].y = totalLegLength;
			outerPoints[index].x += (this.outerLoose-1)*(max_skirt_width*this.legCoverage);
			
			if(!this.bustle){	//for males with low legFem, quickfix, awful, should be done simpler way
				let temp = interpolateCurve(outerPoints[index-1],outerPoints[index],{x:null,y:ex.thigh.out.y});
				if(temp[0].x<ex.thigh.out.x){
					outerPoints[index+1] = extractPoint(outerPoints[index]);
					outerPoints[index] = ex.thigh.out;
				}
			};
		
		}else{ //short skirt
			outerPoints = getLimbPoints(ex.hip,ex.ankle.out,this.legCoverage,...addPointsStart,thighOut);
			outerPoints[outerPoints.length-1].y = totalLegLength;
			outerPoints[outerPoints.length-1].x += (this.outerLoose-1)*(max_skirt_width*this.legCoverage);
		}
		
	}else if(this.outerLoose>0){ //LOOSE
		let max;
		if(typeof ex.quads !== "undefined"){
			max = findBetween(ex.quads.out.x,ex.quads.out.cp1.x,0.5);
		}else{ 
			max = ex.thigh.out.x;
		}
		
		outerPoints = getLimbPoints(ex.hip,ex.ankle.out,this.legCoverage,...addPointsStart,thighOut,...addPointsMid,ex.knee.out,ex.calf.out,ex.ankle.out);
		
		//adjust X but not more than max & smooth control points 
		let skipped_points=addPointsStart.length+1; //hip+thigh;
		if(addPointsMid.length>0){
			skipped_points++;//+muscles
		}
		
		for(let ii=skipped_points;ii<outerPoints.length;ii++){
			outerPoints[ii].x = findBetween(outerPoints[ii].x,max,this.outerLoose);
			if(outerPoints[ii].cp1){ 
				outerPoints[ii].cp1.x = findBetween(outerPoints[ii].cp1.x,max,this.outerLoose) 
			}
			if(outerPoints[ii].cp2){ 
				outerPoints[ii].cp2.x = findBetween(outerPoints[ii].cp2.x,max,this.outerLoose) 
			}
		}	
	}else{//TIGHT
		outerPoints = getLimbPoints(ex.hip,ex.ankle.out,this.legCoverage,out,hip,thighOut,...addPointsMid,ex.knee.out,ex.calf.out,ex.ankle.out);
	}		
		
	//INNER
	let innerPoints = [];
		//?? use caluculated groin
	if(this.innerLoose>=1){
		innerPoints = getLimbPointsAbovePoint(outerPoints[outerPoints.length-1],true,top,ex.thigh.in,ex.knee.intop,ex.knee.in,ex.calf.in,ex.ankle.in);
	}else{
		innerPoints = getLimbPointsAbovePoint(outerPoints[outerPoints.length-1],true,groin,ex.thigh.in,ex.knee.intop,ex.knee.in,ex.calf.in,ex.ankle.in);
	}

	innerPoints[0] = extractPoint(innerPoints[0]);
	
	//ADJUST INNER POINTS to not reach into negative values 
 	if(this.innerLoose>0){
		innerPoints[0].x -=  innerPoints[0].x * this.innerLoose;
		
		for (let ii=1; ii<innerPoints.length; ii++){ 
			//transformCurve(t, p1, initP2, endP2)
			innerPoints[ii] = transformCurve(this.innerLoose, innerPoints[ii-1], innerPoints[ii], {x:0,y:innerPoints[ii].y});
		}
	}
	
	//CURVED BOTTOM
	if(this.innerLoose<1&&innerPoints[0].y<ex.groin.y){ //pants
		innerPoints[0].cp1 = {
			x : findBetween(outerPoints[outerPoints.length-1].x,innerPoints[0].x,0.5),
			y : innerPoints[0].y+3,
		};	
	}else if(this.innerLoose>=1){ //skirt
		outerPoints[outerPoints.length-1].y += 2;
		innerPoints[0].y -= 2;
		innerPoints[0].x -= 0.2;
		innerPoints[0].cp1 = {
			x: innerPoints[0].x * 0.5 + outerPoints[outerPoints.length-1].x * 0.5,
			y: innerPoints[0].y 
		};
	}	

    return {
        top,
		out,
        hip,
        thighOut,
        groin,
		outerPoints,
		innerPoints,
    };
}

export function calcSuperPantsZip(ex) {
	let {top, out, hip, thighOut, groin, outerPoints, innerPoints} = calcSuperPants.call(this,ex); 
	
	//ZIP
	let temp;
	temp = splitCurve(this.zipOpen,top,out);	
	let mid = extractPoint(temp.left.p2);
	out = temp.right.p2;
	
	temp = splitCurve(this.zipDeep,top,groin);	
	let zip = {x:-0.2,y:temp.left.p2.y};
	
    return {
		zip,
        top,
		mid,
		out,
        hip,
        thighOut,
        groin,
		outerPoints,
		innerPoints,
    };
}




export class SuperPantsPart extends ClothingPart {
    constructor(...data) {
        super({
            layer     : Layer.FRONT,
            loc       : "leg",
            aboveParts: ["parts leg"],
		//	belowSameLayerParts: ["torso"],
        }, ...data);
    }

    renderClothingPoints(ex, ctx) {
        const {top, out, hip, thighOut, groin, outerPoints, innerPoints} = calcSuperPants.call(this,ex);

        Clothes.simpleStrokeFill(ctx, ex, this);

		if(this.innerLoose>=1){ //skirt - do not draw the middle line
			ctx.beginPath();
			drawPoints(ctx, top, ...outerPoints, innerPoints[0],top);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints, innerPoints[0]);
			ctx.stroke();
		}else{
			ctx.beginPath();
			drawPoints(ctx, top, ...outerPoints,  ...innerPoints, groin, top);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints,  ...innerPoints, groin);
			ctx.stroke();
		}
		
		//belt
		ctx.beginPath();
		ctx.lineWidth = this.belt;
		drawPoints(ctx, top,adjust(out,-0.5,0));
		ctx.stroke();
	}
}

/**
	the same thing as SuperPantsPart, but drawn BELLOW shirts
*/
export class SuperLegginsPart extends ClothingPart {
    constructor(...data) {
        super({
            layer     : Layer.FRONT,
            loc       : "leg",
            aboveParts: ["parts leg"],
			belowSameLayerParts: ["torso"],
        }, ...data);
    }

    renderClothingPoints(ex, ctx) {
        const {top, out, hip, highOut, groin, outerPoints, innerPoints} = calcSuperPants.call(this,ex);

        Clothes.simpleStrokeFill(ctx, ex, this);

		if(this.innerLoose>=1){ //skirt - do not draw the middle line
			ctx.beginPath();
			drawPoints(ctx, top, ...outerPoints, innerPoints[0],top);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints, innerPoints[0]);
			ctx.stroke();
					
		}else{
			ctx.beginPath();
			drawPoints(ctx, top, ...outerPoints,  ...innerPoints, groin, top);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints,  ...innerPoints, groin);
			ctx.stroke();
		}
		
		//belt
		ctx.beginPath();
		ctx.lineWidth = this.belt;
		drawPoints(ctx, top,adjust(out,-0.5,0));
		ctx.stroke();
	}
}


/**
	the same thing as SuperPantsPart, but drawn in MIDRIFT layer
*/
export class SuperSkirtPart extends ClothingPart {
    constructor(...data) {
        super({
            layer     : Layer.MIDRIFT,
            loc       : "leg",
            aboveParts: ["parts leg"],
		//	belowSameLayerParts: ["torso"],
        }, ...data);
    }

    renderClothingPoints(ex, ctx) {
        const {top, out, hip, thighOut, groin, outerPoints, innerPoints} = calcSuperPants.call(this,ex);

        Clothes.simpleStrokeFill(ctx, ex, this);

		if(this.innerLoose>=1){ //skirt - do not draw the middle line
			ctx.beginPath();
			drawPoints(ctx, top, ...outerPoints, innerPoints[0],top);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints, innerPoints[0]);
			ctx.stroke();
		}else{
			ctx.beginPath();
			drawPoints(ctx, top, ...outerPoints,  ...innerPoints, groin, top);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints,  ...innerPoints, groin);
			ctx.stroke();
		}
		
		//belt
		ctx.beginPath();
		ctx.lineWidth = this.belt;
		drawPoints(ctx, top,adjust(out,-0.5,0));
		ctx.stroke();
	}
}


export class LacedLegginsPart extends ClothingPart {
    constructor(...data) {
        super({
            layer     : Layer.FRONT,
            loc       : "leg",
            aboveParts: ["parts leg"],
			belowSameLayerParts: ["torso"],
        }, ...data);
    }

    renderClothingPoints(ex, ctx) {
        const {zip, top, mid, out, hip, highOut, groin, outerPoints, innerPoints} = calcSuperPantsZip.call(this,ex);

        Clothes.simpleStrokeFill(ctx, ex, this);

		if(this.innerLoose>=1){ //skirt - do not draw the middle line
			ctx.beginPath();
			drawPoints(ctx, zip, mid, ...outerPoints, innerPoints[0], zip);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints, innerPoints[0]);
			ctx.stroke();
					
		}else{
			ctx.beginPath();
			drawPoints(ctx, zip, mid, ...outerPoints,  ...innerPoints, groin, zip);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, ...outerPoints,  ...innerPoints, groin);
			ctx.stroke();
		}
		
		//LACING!!
		const crosses = this.crosses > 0 ? this.crosses : 3;
		const points = getLacingPoints(zip,mid,zip,reflect(mid),crosses,1);
		ctx.lineWidth = 1;
		ctx.beginPath();
		drawPoints(ctx, ...points.inner, breakPoint, ...points.outer);
		ctx.stroke();
		
		//belt
		ctx.beginPath();
		ctx.lineWidth = this.belt;
		drawPoints(ctx,mid,adjust(out,-0.5,0));
		ctx.stroke();
	}
}


export class JeansPart extends ClothingPart {
    constructor(...data) {
        super({
            layer     : Layer.FRONT,
            loc       : "leg",
            aboveParts: ["parts leg"],
		//	belowSameLayerParts: ["torso"],
        }, ...data);
    }

    renderClothingPoints(ex, ctx) {
        const {zip, top, mid, out, hip, thighOut, groin, outerPoints, innerPoints} = calcSuperPantsZip.call(this,ex);

        Clothes.simpleStrokeFill(ctx, ex, this);

		if(this.innerLoose>=1){ //skirt - do not draw the middle line
			ctx.beginPath();
			drawPoints(ctx, zip, mid, ...outerPoints, innerPoints[0], zip);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, zip, mid, ...outerPoints, innerPoints[0]);
			ctx.stroke();
		}else{
			ctx.beginPath();
			drawPoints(ctx, zip, mid, ...outerPoints,  ...innerPoints, groin, zip);
			ctx.fill(); 
			
			ctx.beginPath();
			drawPoints(ctx, zip, mid, ...outerPoints,  ...innerPoints, groin);
			ctx.stroke();
		}
		
		 
		
		//ctx.lineWidth = 0.5;
		//ctx.setLineDash([1,2]);
		//ctx.strokeStyle = "orange";
		
		ctx.lineWidth = 0.5;
		ctx.beginPath();
		drawPoints(ctx, adjust(mid,1,-3), adjust(out,0,-3));
		ctx.stroke();
		
		
		//unbuttoned pants
		let a = mid.x;
		let b = top.y - zip.y;
		let t = Math.atan(a/b);
		let fin = polar2cartesian(b, -1.6*t+Math.PI/2 , zip)
		
		ctx.fillStyle = adjustColor(ctx.fillStyle, {
			s: -10,
			l: 10
		}); 
		ctx.beginPath();
		drawPoints(ctx, zip, fin, mid);
		ctx.fill();
		ctx.stroke();
		
	}
}

export class LoinclothPart extends ClothingPart {
    constructor(...data) {
        super({
            layer     : Layer.FRONT, //MIDRIFT, //dunno, could be both
            loc       : "leg",
            aboveParts: ["parts leg"],
        }, ...data);
    }

    renderClothingPoints(ex, ctx) {
		Clothes.simpleStrokeFill(ctx, ex, this);
		let temp;
		
		//BELT
		const belt = calcBelt.call(this, ex);
		
		//CLOTH
		const cloth = {};
		
		//top - copy of bottom belt
		cloth.inTop = extractPoint(belt.inBot);
		temp = splitCurve(this.topCoverage,belt.inBot,belt.outBot);
		cloth.outTop = extractPoint(temp.left.p2);
		cloth.outTop.cp1 = belt.inBot.cp1;
			
		//leg coverage 
		const lowestY = findBetween(ex.ankle.out.y,ex.hip.y,1-this.legCoverage)
		
		temp = splitCurve(this.bottomCoverage,belt.inBot,belt.outBot);
		cloth.outBot = {
			x: temp.left.p2.x,
			y: lowestY
		};
		
		temp = splitCurve(0.3,cloth.outTop,cloth.outBot);
		cloth.outBot.cp1=temp.left.p2;

		cloth.outBot.cp1.x += this.curveX;
		cloth.outBot.cp1.y += this.curveY;
						
		//bottom & bottom curve
		cloth.inBot = {
			x: -0.2,
			y: lowestY - (4*this.bottomCoverage)
		};
		cloth.inBot.cp1 = {
			x: findBetween(cloth.outBot.x,cloth.inBot.x),
			y: cloth.inBot.y
		};
		
		
		ctx.beginPath();
		drawPoints(ctx, 
			cloth.inTop,
			cloth.outTop,
			cloth.outBot,
			cloth.inBot,
		);
		 
		ctx.stroke();
		ctx.fill();			
		
		ctx.fillStyle = this.highlight;
		ctx.beginPath();
		drawPoints(ctx, 
			belt.inTop,
			belt.outTop,
			belt.outMid,
			belt.outBot,
			belt.inBot,
		);
		 
		ctx.stroke();
		ctx.fill();
		
	}
}

/*

*/
export class SuperPants extends Pants {
    constructor(...data) {
        super({
            clothingLayer: Clothes.Layer.MID,
            innerLoose: 0,
			outerLoose: 0,
			legCoverage: 0.9,
			waistCoverage: 0.5,
			opacity: 1,
			thickness: 1,
			bustle:false,
			belt: 2,
        }, ...data);
    }

	fill() {
        return "hsl(200, 65%, 20%)";
    }
	
	stroke() {
       return "hsl(200, 50%, 10%)";
    }
	
    get partPrototypes() {
        return [
     /*       {
                side: null,
                Part: SuperButtPart,
           },
    */      {
                side: Part.LEFT,
                Part: SuperPantsPart
            },
            {
                side: Part.RIGHT,
                Part: SuperPantsPart
            },
        ];
    }
}

export class SuperLeggins extends Pants {
    constructor(...data) {
        super({
            clothingLayer: Clothes.Layer.MID,
            innerLoose: 0,
			outerLoose: 0,
			legCoverage: 0.9,
			waistCoverage: 0.5,
			opacity: 1,
			thickness: 1,
			bustle:false,
			belt: 2,
        }, ...data);
    }

	fill() {
        return "hsla(200, 0%, 20%, 1)";
    }
	
	stroke() {
       return "hsla(200, 0%, 10%, 1)";
    }
	
	
	
    get partPrototypes() {
        return [{
   /*         {
                side: null,
                Part: SuperButtPart,
            },
     */       
                side: Part.LEFT,
                Part: SuperLegginsPart
            },{
                side: Part.RIGHT,
                Part: SuperLegginsPart
            },
        ];
    }
}

export class SuperSkirt extends Pants {
    constructor(...data) {
        super({
            clothingLayer: Clothes.Layer.MID,
            innerLoose: 1,
			outerLoose: 1.3,
			legCoverage: 0.4,
			waistCoverage: 0.1,
			opacity: 1,
			thickness: 1,
			bustle:false,
			belt: 2,
        }, ...data);
    }

	fill() {
        return "hsl(0, 65%, 20%)";
    }
	
	stroke() {
       return "hsl(0, 50%, 10%)";
    }
	
    get partPrototypes() {
        return [{
     /*       {
                side: null,
                Part: SuperButtPart,
           },
    */      
                side: Part.LEFT,
                Part: SuperSkirtPart
            },{
                side: Part.RIGHT,
                Part: SuperSkirtPart
            },
        ];
    }
}


export class LacedLeggins extends Pants {
    constructor(...data) {
        super({
            clothingLayer: Clothes.Layer.MID,
            
			zipOpen: 0.2, //TODO
			zipDeep: 0.3,
			crosses: 4,
			
			innerLoose: 0,
			outerLoose: 0,
			legCoverage: 0.9,
			waistCoverage: 0.4,
			opacity: 1,
			thickness: 1,
			bustle:false,
			
        }, ...data);
    }

	fill() {
        return "hsla(200, 0%, 20%, 1)";
    }
	
	stroke() {
       return "hsla(200, 0%, 10%, 1)";
    }
	
	
	
    get partPrototypes() {
        return [{
    /*        {
                side: null,
                Part: CoveredButtPart,
            },{
    */      
                side: Part.LEFT,
                Part: LacedLegginsPart
            },{
                side: Part.RIGHT,
                Part: LacedLegginsPart
            },
        ];
    }
}

export class Jeans extends Pants {
    constructor(...data) {
        super({
            clothingLayer: Clothes.Layer.MID,
            innerLoose: 0,
			outerLoose: 0,
			legCoverage: 0.9,
			waistCoverage: 0.4,
			opacity: 1,
			thickness: 1,
			bustle:false,
			belt: 2,
			
			zipOpen: 0.01,  //TODO
			zipDeep: 0.21,
			highlight: "orange", 
        }, ...data);
    }

	fill() {
        return "hsl(200, 65%, 20%)";
    }
	
	stroke() {
       return "hsl(200, 50%, 10%)";
    }
	
    get partPrototypes() {
        return [
     /*       {
                side: null,
                Part: SuperButtPart,
           },
    */      {
                side: Part.LEFT,
                Part: JeansPart
            },
            {
                side: Part.RIGHT,
                Part: JeansPart
            },
        ];
    }
}

export class Loincloth extends Pants {
    constructor(...data) {
        super({
            waistCoverage: 0.42,
			
			beltWidth: 4,
			beltCurve:-3.5,
			
			thickness: 1,
			
			topCoverage: 0.8,
			legCoverage: 0.5,
			bottomCoverage: 0.14,
			
			curveX: -16,
			curveY: 14,
		
			highlight:"hsla(33, 80%, 10%, 1)",

        }, ...data);
    }
	
	fill() {
        return "hsla(33, 45%, 35%, 1)";
    }
	
	stroke() {
       return "hsla(33, 45%, 25%, 1)";
    }
	 
    get partPrototypes() {
        return [
            {
                side: Part.LEFT,
                Part: LoinclothPart
            },
            {
                side: Part.RIGHT,
                Part: LoinclothPart
            },
        ];
    }
}

