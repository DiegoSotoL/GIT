/**
 * Created by johnson on 11.05.17.
 */
import { DrawPoint, Point } from "./point";
declare type LinearReduce<T> = (p1: Point, p2: Point) => T;
declare type QuadraticReduce<T> = (p1: Point, cp: Point, p2: Point) => T;
declare type CubicReduce<T> = (p1: Point, cp1: Point, cp2: Point, p2: Point) => T;
declare type CurveMethods<T> = {
    linear: LinearReduce<T>;
    quadratic: QuadraticReduce<T>;
    cubic: CubicReduce<T>;
};
export declare function applyToCurve<T>(p1: DrawPoint, p2: DrawPoint, { linear, quadratic, cubic }: CurveMethods<T>): T;
/**
 * Get a point at t (out of [0,1]) along the [p1, p2] curve
 * @param t
 * @param p1
 * @param p2
 * @returns {*}
 */
export declare function getPointOnCurve(t: number, p1: DrawPoint, p2: DrawPoint): DrawPoint;
/**
 * Shorthand for getting point on a line connecting p1 -> p2
 * Useful for force treatment of p2 as a linear end point even if it has control points
 * @param t
 * @param p1
 * @param p2
 * @returns {*}
 */
export declare function getPointOnLine(t: number, p1: DrawPoint, p2: DrawPoint): DrawPoint;
declare type SplitSide = {
    p1: DrawPoint;
    p2: DrawPoint;
};
declare type SplitResult = {
    left: SplitSide;
    right: SplitSide;
};
/**
 * Split the curve between two drawpoints and return all the resulting drawpoints
 * @memberof module:da
 * @param {number} t "time" along the curve to split at. Since all curves are parameterized
 * curves, t is their parameter. Can be thought of as traversing along the curve, where 0 is
 * at the start point and 1 is at the end point. This value can go beyond [0,1].
 * @param {object} p1 Starting drawpoint
 * @param {object} p2 Ending drawpoint and also where we look at the control points
 * @returns {{left, right}} Object having a left and right property, each with their own
 * p1 (start point), p2 (end point), and optionally cp1 and cp2 depending on what kind of
 * curve was split. Note that sp.left.p2 === sp.right.p1 always in value.
 */
export declare function splitCurve(t: number, p1: DrawPoint, p2: DrawPoint): SplitResult;
interface InterpolatePoint extends DrawPoint {
    t: number;
}
/**
 * Get points along the curve from t = [0,1] that share the fixed dimension as betweenPoint.
 * For example, if betweenPoint = {x:10, y:null}, then we are looking for all points with
 * x = 10.
 * @param p1
 * @param p2
 * @param betweenPoint Query that has either x or y set to null which is to be determined
 * @returns {Array} List of draw points that have a "t" property which is how far they are along the curve
 */
export declare function interpolateCurve(p1: DrawPoint, p2: DrawPoint, betweenPoint: Point): InterpolatePoint[];
/**
 * Return the control point for a quadratic curve between two points with
 * a simple deflection parameter
 * @param p1
 * @param p2
 * @param t How far along the linear between p1 and p2 the control point should start
 * @param deflection Which direction and how far perpendicular to the p1-p2 linear
 * the control point should be (the norm of the perpendicular vector)
 * @returns {{x: number, y: number}}
 */
export declare function simpleQuadratic(p1: DrawPoint, p2: DrawPoint, t?: number, deflection?: number): DrawPoint;
/**
 * Increase the degree of a cubic curve (e.g. quadratic to cubic) without changing its shape
 * @param p1 Starting point of the curve
 * @param p2 Ending point of the curve and holds the other control points
 */
export declare function elevateDegree(p1: DrawPoint, p2: DrawPoint): DrawPoint;
/**
 * Get the cubic cubic control point representation of the curve from start to end.
 * If end already has 2 control points return them; if end has only 1 control point (quadratic)
 * then return 2 control points that would lead to an equivalent curve; if end has no control
 * point (linear) then return 2 control points located identically at the midpoint between
 * start and end.
 * @param p1
 * @param p2
 * @returns {[*,*]} cp1 and cp2 of end point
 */
export declare function getCubicControlPoints(p1: DrawPoint, p2: DrawPoint): [DrawPoint, DrawPoint];
/**
 * Transform start curve into end curve (results in cubic cubic) with the amount
 * of transformation determined by t [0,1]. Limited to transforming the end point as the start and
 * end curves must have the same starting point
 * @param t Amount to transform, [0,1] 0 is no transformation at all and is equal to the start curve;
 * 1 is full transformation and is equal to the end curve
 * @param p1
 * @param initP2
 * @param endP2
 * @returns Replacement draw point for endP2
 */
export declare function transformCurve(t: number, p1: DrawPoint, initP2: DrawPoint, endP2: DrawPoint): DrawPoint;
/**
 * Given a curve defined by (start, end), return a draw point such that (end, returned point) looks identical,
 * but travels in the opposite direction.
 * @param start
 * @param end
 * @returns {*}
 */
export declare function reverseDrawPoint(start: DrawPoint, end: DrawPoint): DrawPoint;
/**
 * Get a control point that would ensure a smooth continuation from the input curve when
 * used as cp1 either for a quadratic or cubic curve.
 * @param {point} p1 Start point of a curve
 * @param {point} p2 End point of a curve
 * @param {number} scaleBy How much back to extend the continuing control point.
 * A value of 1 produces a symmetric curve.
 * @returns {{x, y}|{x: number, y: number}|*} Continuing control point
 */
export declare function continueCurve(p1: DrawPoint, p2: DrawPoint, scaleBy?: number): Point;
export {};
