"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tracePoint = exports.drawSpecificCurl = exports.drawCircle = exports.drawPoints = exports.none = void 0;
var point_1 = require("./point");
var curve_1 = require("./curve");
// noinspection JSUnusedGlobalSymbols
/**
 * Styling option to not show stroke or fill
 * @readonly
 * @type {string}
 */
exports.none = "rgba(0,0,0,0)";
// noinspection JSUnusedGlobalSymbols
/**
 * Draw the path formed by the list of drawpoints
 * @param {Context2DTracked} ctx Context2D to render to, if it exists
 * @param {Object[]} points Ordered list of draw points, each with x and y
 */
function drawPoints(ctx) {
    var points = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        points[_i - 1] = arguments[_i];
    }
    // given ctx and a list of points, draw points between them based on how many control points
    // are defined for each
    // does not begin a path or fill or stroke (just moves pen between the points)
    if (points.length < 1) {
        return;
    }
    var startPoint = points[0];
    // if null is passed through, just continue from last location
    if (startPoint) {
        if (startPoint === point_1.breakPoint) {
            startPoint = points[1];
        }
        if (startPoint && startPoint.hasOwnProperty("x")) {
            ctx.moveTo(startPoint.x, startPoint.y);
        }
    }
    // for every point after
    for (var i = 1, len = points.length; i < len; ++i) {
        var p = points[i];
        // allow calls with nonexistent points so that different drawing modes can be
        // consolidated
        if (!p) {
            // console.log("don't have point #", i);
            continue;
        }
        if (p === point_1.breakPoint) {
            ++i;
            if (i < points.length) {
                p = points[i];
                ctx.moveTo(p.x, p.y);
            }
        }
        else if (p.cp2 && p.cp1) {
            ctx.bezierCurveTo(p.cp1.x, p.cp1.y, p.cp2.x, p.cp2.y, p.x, p.y, p.traceOptions);
        }
        else if (p.cp1) {
            ctx.quadraticCurveTo(p.cp1.x, p.cp1.y, p.x, p.y, p.traceOptions);
        }
        else if (p.cp2) {
            ctx.quadraticCurveTo(p.cp2.x, p.cp2.y, p.x, p.y, p.traceOptions);
        }
        else if (p.hasOwnProperty("x")) {
            ctx.lineTo(p.x, p.y);
        }
    }
}
exports.drawPoints = drawPoints;
// noinspection JSUnusedGlobalSymbols
/**
 * Get the drawpoints for a circle
 * @param {object} center Point at the center of the circle
 * @param {number} radius Radius in cm
 * @returns {object[]} List of draw points for this circle (could be passed to guiMenuItem)
 */
function drawCircle(center, radius) {
    var stretch = 0.552284749831 * radius;
    var top = {
        x: center.x,
        y: center.y + radius,
        cp1: undefined,
        cp2: undefined,
    };
    var right = {
        x: center.x + radius,
        y: center.y,
        cp1: undefined,
        cp2: undefined,
    };
    var bot = {
        x: center.x,
        y: center.y - radius,
        cp1: undefined,
        cp2: undefined,
    };
    var left = {
        x: center.x - radius,
        y: center.y,
        cp1: undefined,
        cp2: undefined,
    };
    top.cp1 = {
        x: left.x,
        y: left.y + stretch
    };
    top.cp2 = {
        x: top.x - stretch,
        y: top.y
    };
    right.cp1 = {
        x: top.x + stretch,
        y: top.y
    };
    right.cp2 = {
        x: right.x,
        y: right.y + stretch
    };
    bot.cp1 = {
        x: right.x,
        y: right.y - stretch
    };
    bot.cp2 = {
        x: bot.x + stretch,
        y: bot.y
    };
    left.cp1 = {
        x: bot.x - stretch,
        y: bot.y
    };
    left.cp2 = {
        x: left.x,
        y: left.y - stretch
    };
    // doesn't actually matter in which order you draw them
    return [top, right, bot, left, top];
}
exports.drawCircle = drawCircle;
// noinspection JSUnusedGlobalSymbols
function drawSpecificCurl(left, center, right) {
    var p1 = point_1.extractPoint(left);
    var p2 = point_1.extractPoint(center);
    var p3 = point_1.extractPoint(right);
    {
        var _a = left.t, t = _a === void 0 ? 0.5 : _a, _b = left.deflection, deflection = _b === void 0 ? 0.5 : _b;
        p2.cp1 = curve_1.simpleQuadratic(p1, p2, t, deflection);
    }
    {
        var _c = right.t, t = _c === void 0 ? 0.5 : _c, _d = right.deflection, deflection = _d === void 0 ? 0.5 : _d;
        p3.cp1 = curve_1.simpleQuadratic(p1, p2, t, deflection);
    }
    return [p1, p2, p3];
}
exports.drawSpecificCurl = drawSpecificCurl;
// noinspection JSUnusedGlobalSymbols
/**
 * Debug the curve going into a drawpoint. Use by wrapping a drawpoint with it when returning
 * to guiMenuItem.
 * @param {object} pt
 * @param {object} options Options for how to show the points
 * @returns {*}
 */
function tracePoint(pt, options) {
    if (!options) {
        options = { radius: 1 };
    }
    else if (typeof options === "number") {
        // convenience for defining radius of trace point
        options = { radius: options };
    }
    pt.traceOptions = { point: options };
    return pt;
}
exports.tracePoint = tracePoint;
//# sourceMappingURL=draw.js.map